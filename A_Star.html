<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>A* </title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
        <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
        
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet">
        <link rel="icon" href="img/log.png" sizes="32x32">
        <link rel="stylesheet" href="css/main.css">
        <link rel="stylesheet" href="css/A.css">
    </head>
    <body>
    
        <nav class="navbar">
            <ul class="slidebar">
                <li onclick=hideSidebar()><a href="#"><svg xmlns="http://www.w3.org/2000/svg" height="26" viewBox="0 96 960 960" width="26"><path d="m249 849-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z"/></svg></a></li>
                <li> <h4 class="about"><a href="about.html">About</a></h4></li>
                <li> <h4 class="help"><a href="help.html">Help</a></h4></li>
                <li> <div class="algocode" ><h4>AlgoCode</h4></div></li>
            </ul>
            <div class="section1" onclick="window.location.href='index.html'" style="cursor: pointer;"><h4>ALGOVERSE</h4></div>
            <div class="section2">
               <li> <h4 class="about"><a href="about.html">About</a></h4></li>
               <li> <h4 class="help"><a href="help.html">Help</a></h4></li>
               <li  style="border:none;" > <div class="algocode" style="border:none;"><h4>AlgoCode</h4></div></li>
               <li class="menu-button" onclick=showSidebar()><svg xmlns="http://www.w3.org/2000/svg" height="26" viewBox="0 96 960 960" width="26"><path d="M120 816v-60h720v60H120Zm0-210v-60h720v60H120Zm0-210v-60h720v60H120Z" fill="#fff" /></svg></li>
            </div>
        </nav>
        
        <div id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>A*</h3>
                <button class="close-btn" onclick="closeSidebar()" ><span class="material-symbols-outlined" id="close">
                    close
                    </span></button>
            </div>
            <ul>
                <li class="has-submenu">
                    <a href="javascript:void(0);" onclick="toggleSubmenu1()" class="menu-title">
                        Description &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <i class="fa-solid fa-angle-down arrow-icon"></i>
                    </a>
                    <div class="submenu" id="submenu1">
                        <div class="step-indicator">
                            <div class="step" id="step1">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Theory" class="sidebar-link">Theory</a></div>
                            </div>
                            <div class="step" id="step2">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Advantages" class="sidebar-link">Advantages</a></div>
                            </div>
                            <div class="step" id="step3">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Disadvantages" class="sidebar-link">Disadvantages</a></div>
                            </div>
                            <div class="step" id="step4">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Applications" class="sidebar-link">Applications</a></div>
                            </div>
                        </div>
                    </div>
                </li>
                
                
                <li class="has-submenu">
                    <a href="javascript:void(0);" onclick="toggleSubmenu2()">Algorithm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <i class="fa-solid fa-angle-down arrow-icon2" ></i>
                    </a>
                    <ul class="submenu" id="submenu2">
                        <div class="step-indicator2">
                            <div class="step" id="step1">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#pseudocode">Pseudocode</a></div>
                            </div>
                        </div>
                    </ul>
                </li>
                
                <li><a href="#Visualization">Visualization</a></li>
                <li><a href="#complexity" >Time complexity</a></li>
                <li><a href="#scomplexity" >Space Complexity</a></li>
            </ul>
        </div>
        
    
        <button class="menu-btn" onclick="openSidebar()"><span class="material-symbols-outlined" style="color:#fff;">
            dock_to_left
            </span></button>

            <div class="content">
                <div id="Theory" class="content-container">
                    
                     <div class="article-title">
                       <h1>A* algorithm</h1>
                    </div>
                    <br>
                    <hr>
                    <br>
                    <div class="text" style="height: auto; overflow: hidden;">
                        <p dir="ltr" style="text-align: justify;">
        
                           <b>A* Algorithm:</b> The A* algorithm finds the shortest path from a start node to a goal node using a combination of:
<br><br>
&nbsp; &nbsp; &nbsp;Actual cost from the start node to the current node ( g(n)).<br><br>
&nbsp; &nbsp; &nbsp;Heuristic estimate of the cost from the current node to the goal node ( h(n)).</p><br><br>
                        
                        <p dir="ltr" style="text-align: justify;">
                            <h2>HOW IT WORKS?</h2>
                            <p>
                                The A* algorithm works by combining Dijkstra's algorithm and greedy best-first search to efficiently find the shortest path from a start node to a goal node. It does this using a priority queue to explore nodes based on their estimated total cost.
                            </p>
                            <ol>
                               
                              
                                <li><strong>Initialize:</strong><br><br>
                                    &nbsp; &nbsp;Add the start node to the open list (priority queue) with its  f(n)=g(n)+h(n), where<br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;g(n): The actual cost to reach node <br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;h(n): Heuristic estimate of the cost to reach the goal from node<br><br> 

                                </li>
                                <li><strong>Main Loop:</strong><br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;Select the node with the lowest f(n) from the open list.<br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;Move it to the closed list (evaluated nodes). <br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;For each neighbor of the selected node, calculate its  f(n), and if it's not in the open list, add it. If it is already in the open list but a better path is found, update its values.<br><br> 

                                </li>
                                <li><strong>End Condition:</strong><br><br> 
                                    &nbsp; &nbsp; &nbsp; &nbsp;If the goal is reached, reconstruct the path from the goal node to the start node.
                                    <br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;If the open list is empty without reaching the goal, no path exists.<br><br>
                                   

                                </li>
                                
                            </ol>
                            
                            
                        </div>
                    </div>
        
        <!-- advantages -->
        
                <div id="Advantages" class="content-container">
                    <div class="article-title text">
                        <h1>Advantages</h1>
                     </div>
                     <br>
                     <hr>
                     <br><br>
                    <div class="article-title text">
                        
                            <ol>
                               
                                    <ul>
                                        <li><strong>Optimality:</strong> A* guarantees finding the shortest path if the heuristic  h(n) is admissible (i.e., it does not overestimate the actual cost to reach the goal).</li>
                                   <br><br>
                               
                                
                                        <li><strong>Efficiency:</strong>It combines the advantages of both greedy best-first search (which uses a heuristic) and Dijkstra's algorithm (which ensures the shortest path), making it much more efficient than brute force search methods.</li><br><br>
                                
                                        <li><strong>Flexibility:</strong>The performance of A* can be adjusted based on the heuristic used. A more accurate heuristic results in faster pathfinding.</li>
                                    <br><br>
                               
                                   
                                        <li><strong>Versatile:</strong> A* can be applied to a wide range of problems such as pathfinding in games, robot navigation, GPS routing, and other optimization problems.

        
                                        </li>
                                   <br><br>
                                
                                   <li><strong>Complete:</strong> A* is complete, meaning it will always find a solution (if one exists) by exploring all possible paths if necessary.
                                    
                                   </li>
                                   <br><br>
                                  
                                </ul>
                            </ol>
                        
                        
                     </div>
        
                </div>
        
        
        <!-- disadvantages -->
        
        
                <div id="Disadvantages" class="content-container">
                    <div class="article-title text">
                        <h1>Disadvantages</h1>
                     </div>
                     <br>
                     <hr>
                     <br><br>
                    <div class="article-title text">
                        <ol>
                            <ul>
                                <li><strong>High Memory Consumption:</strong>A* stores all visited nodes in memory (both the open and closed lists), which can be prohibitive for large or complex graphs, leading to high space complexity.</li>
                           <br><br>
                       
                        
                                <li><strong>Slow for Large Graphs:</strong>The algorithm can be slow when dealing with large search spaces or graphs, especially when the heuristic is not very accurate or when the graph is very dense.
        
                                </li><br><br>
                        
                                <li><strong>Depends on the Heuristic:</strong>A*'s performance depends heavily on the quality of the heuristic function. If the heuristic is not well-designed or admissible, the algorithm might degrade to less efficient searches like Dijkstra’s.
                                </li>
                            <br><br>
                       
                           
                                <li><strong>Complexity of Heuristic:</strong>Designing an appropriate heuristic for some problems can be challenging, and a poorly designed heuristic can significantly slow down the search.
        
                                </li>
                           <br><br>
                        
                           <li><strong>Computational Overhead:</strong>For some problems, calculating the heuristic value at each step may require significant computation, which can add overhead to the algorithm's runtime.
                           </li>
                           <br><br>
                           
                        </li>
                        </ul>
                        </ol>
                    
                     </div>
        
                </div>
        
        
        <!-- applications -->
        
        
                <div id="Applications" class="content-container">
                    <div class="article-title text">
                        <h1>Applications</h1>
                     </div>
                     <br>
                     <hr>
                     <br>
                    <div class="article-title text">
                        <ol>
                            <ul>
                                <li><strong>Pathfinding in Games:</strong> A* is used in video games for AI-controlled characters to find the most efficient route on a game map.
                                    <br>A* helps characters avoid obstacles and navigate complex environments, such as mazes or 3D worlds.
                                    </li>
                           <br><br>
                       
                        
                                <li><strong> Robotics and Autonomous Vehicles:</strong>A* is used to plan paths for robots in environments, helping them navigate around obstacles to reach a destination efficiently.
                                    <br> It helps autonomous vehicles plan the best route on roads while avoiding obstacles or traffic.
        
        
                                </li><br><br>
                        
                                <li><strong>GPS Navigation Systems:</strong> A* is used in GPS systems for driving or walking directions, finding the shortest or fastest route between two locations based on road maps.</li>
                            <br><br>
                       
                           
                                <li><strong>  AI and Machine Learning:</strong>A* is used to solve puzzles like the 8-puzzle or 15-puzzle, where the goal is to rearrange tiles in a minimum number of moves.
                                    <br>It is used in problems that involve searching large state spaces, such as in decision-making or planning in AI systems.
        
                                </li>
                           <br><br>
                        
                           <li><strong> Network Routing: </strong> A* can be used for routing packets in networks, finding the most efficient path for data transmission in communication networks.
        
                           </li>
                           <br><br>
                           <li><strong> Computer Networks:</strong> A* can be used to optimize the routing of data through various nodes in large networks to minimize latency or maximize throughput.
        
                           </li>
                           <br><br>
                
                        </ul>
                        </ol>
                    
                     </div>
                </div>
        
        
        
                <!-- pseudocode -->
        
                <div id="pseudocode" class="content-container">
                    <div class="article-title text">
                        <h1>Pseudocode</h1>
                     </div>
                     <br>
                     <hr>
                     <br><br>
        <div class="pseudo">
            <div class="article-title text" style="border-radius: 7px; justify-content: center; align-items: center; margin-left: 4px; width: 90%;">
                <h4 style="margin-left: 10px; font-size:15px;font-weight:600">
                    function A_star(start, goal):<br>
                    open_list = priority queue containing the start node<br>
                    closed_list = empty set<br>
                    g(start) = 0<br>
                    h(start) = heuristic estimate from start to goal<br>
                    f(start) = g(start) + h(start)<br>
                
                    while open_list is not empty:<br>
                    &nbsp; &nbsp;current_node = node with the lowest f(n) in open_list<br>
                    &nbsp; &nbsp;if current_node == goal:<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;return reconstruct_path(current_node)<br>
                        
                    &nbsp; &nbsp;&nbsp; &nbsp;remove current_node from open_list<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;add current_node to closed_list<br>
                
                    &nbsp; &nbsp;if neighbor in closed_list:<br>
                    &nbsp; &nbsp;&nbsp; &nbsp; continue<br>
                    &nbsp; &nbsp;tentative_g = g(current_node) + distance(current_node, neighbor)<br>
                
                    &nbsp; &nbsp;if neighbor not in open_list or tentative_g < g(neighbor):<br>
                    &nbsp; &nbsp;&nbsp; &nbsp; g(neighbor) = tentative_g<br>
                    &nbsp; &nbsp;&nbsp; &nbsp; h(neighbor) = heuristic estimate from neighbor to goal<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;f(neighbor) = g(neighbor) + h(neighbor)<br>
                    &nbsp; &nbsp;&nbsp; &nbsp; set current_node as neighbor's parent<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;if neighbor not in open_list:<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; open_list.add(neighbor)<br>
                
                    &nbsp; &nbsp;return failure<br>
                
                function reconstruct_path(goal_node):<br>
                &nbsp; &nbsp;path = empty list<br>
                &nbsp; &nbsp;current_node = goal_node<br>
                &nbsp; &nbsp;while current_node has a parent:<br>
                &nbsp; &nbsp;&nbsp; &nbsp;path.add(current_node)<br>
                &nbsp; &nbsp;&nbsp; &nbsp;current_node = current_node's parent<br>
                &nbsp; &nbsp;return reverse(path)<br>
                
                
            
                </h4><br>
             </div>
             <div class="article-title text">
                <br>
                <h1>Explanation</h1><br>
                <li><strong> Initialization:</strong> <br>Add the start node to the open list with f(start)=g(start)+h(start).   g is the actual cost from the start node, and h is the heuristic estimate to the goal.
                </li><br>
                <li><strong>Main Loop:</strong> <br>
                    While there are nodes in the open list:<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;Select the node with the lowest f(n).<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;If it's the goal node, reconstruct the path and return it.<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;Otherwise, move it to the closed list and evaluate its neighbors.<br>
                    &nbsp; &nbsp;&nbsp; &nbsp;For each neighbor, calculate the tentative cost and update values if a better path is found.<br><br>

                </li>
                <li><strong> Path Reconstruction:</strong> <br>After reaching the goal, trace the path from the goal to the start using parent pointers.


                </li><br>
                <li><strong> End:</strong> <br> If the open list is empty and no path is found, return failure.


                </li>
            </div>
             <br>
        </div>
                </div>
        
        <!-- flowchart -->
        
        
                <div id="flowchart" class="content-container" style="height: auto;">
                    <div class="article-title text">
                        <h1>Flowchart</h1>
                     </div>
                     <br>
                     <hr>
                     <img src="img/insertion_sort.png" alt="AlgoVerse Logo" class="logo" style="width: 500px; /* Specify the width of the image */
                     height: 500px; /* Maintain aspect ratio */
                     border-radius: 5px;
                     box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                     margin-top: 30px;">
                     <br><br>
        
         
                </div>
        
         
        
              
                <!-- visualization -->

                <div id="Visualization" class="content-container">
                    <div class="article-title text">
                        <h1>Visualization</h1>
                    </div>
                    <hr>
                    <div class="cancel" onclick="normalscreen()">
                        <i class="fa-solid fa-xmark"></i>
                    </div>
                    <div class="container">
                        <div class="graph">
                            <!-- Nodes and edges will be added here dynamically -->
                        </div>
                        <div class="info">
                            <h3>Closed List</h3>
                            <ul id="closed-list">
                                <!-- Closed list items will be added here dynamically -->
                            </ul>
                            <div>
                                <label for="source-node">Source Node:</label>
                                <input type="text" id="source-node" value="S">
                            </div>
                            <div>
                                <label for="goal-node">Goal Node:</label>
                                <input type="text" id="goal-node" value="J">
                            </div>
                            <button id="start-btn">Start</button>
                            <button id="path-btn">Find All Paths</button>
                            
                        </div>
                    </div>

                    <div class="screen" onclick="fullscreen()">
                        <i class="fa-solid fa-expand"></i>
                    </div>
                </div>
        <!-- time complexity -->
                <div id="complexity" class="content-container">
                    <div class="article-title text">
                    <h1>Time complexity</h1>
                 </div>
                 <br>
                 <hr><br><br>
                 <p><strong>Definition:</strong> Time complexity measures the amount of time an algorithm takes to complete as a function of the size of the input. For A*, the time complexity can be expressed in different scenarios:</p>
                 <br>
                 <p><strong>Best-Case Time Complexity:O(bd)</strong></p><br>
                       
                 <p>In the best-case scenario, where the heuristic is perfect (i.e., it always gives the exact cost to the goal), the algorithm will find the goal immediately, without exploring many nodes</p>
                 <br><br>
         
                 <p><strong>Average-Case Time Complexity:O(N log N)</strong></p><br>
           
                 <p>In the average case, where the heuristic is reasonably good but not perfect, A* will explore a reasonable number of nodes. </p>
                 <br><br>
                 <p><strong>Worst-Case Time Complexity:O(b<sup>d</sup>log b<sup>d</sup>)</strong></p><br>
           
                 <p>In the worst case, where the heuristic is poor or not informative (e.g., if the heuristic is 0, which makes A* equivalent to Dijkstra’s algorithm), A* might have to explore all the nodes in the search space.</p>
                 <br>
             </div>
        
        
        
        <!-- space compleity -->
        
                <div id="scomplexity" class="content-container">
                    <div class="article-title text">
                    <h1>Space complexity</h1>
                 </div>
                 <br>
                 <hr><br>
              
                 <p><strong>Definition:</strong> Space complexity measures the amount of memory an algorithm uses relative to the size of the input. For A*, the space complexity is straightforward:</p>
                 <br>
                       <p>The space complexity is dominated by the open and closed lists, as they may need to store all nodes in the worst case.</p>
                       Therefore, the overall space complexity of A* is:<strong>O(b<sup>d</sup>)</strong>
             
                </div>
            </div>



<!-- script -->

<script >
    function openSidebar() {
        const sidebar = document.getElementById('sidebar');
        const menuBtn = document.querySelector('.menu-btn');
    
        sidebar.style.width = '280px'; // Set the sidebar width to its full size
        sidebar.style.transform = 'translateX(0)'; // Slide the sidebar into view
        menuBtn.style.display = 'none'; // Hide the menu button
    }
    function closeSidebar() {
        const sidebar = document.getElementById('sidebar');
        const menuBtn = document.querySelector('.menu-btn');
    
        sidebar.style.transform = 'translateX(-100%)'; // Slide the sidebar out of view
        menuBtn.style.display = 'flex'; // Show the menu button
    }
    

function toggleSubmenu1() {
const submenu = document.getElementById("submenu1");
submenu.classList.toggle("expanded");
const arrowIcon = document.querySelector(".arrow-icon");
arrowIcon.style.transform = submenu.classList.contains("expanded") ? "rotate(180deg)" : "rotate(0deg)";
}
function toggleSubmenu2() {
const submenu = document.getElementById("submenu2");
submenu.classList.toggle("expanded");
const arrowIcon = document.querySelector(".arrow-icon2");
arrowIcon.style.transform = submenu.classList.contains("expanded") ? "rotate(180deg)" : "rotate(0deg)";
}



document.addEventListener('DOMContentLoaded', function() {
const sidebar = document.querySelector('.sidebar');

sidebar.addEventListener('click', function(e) {
    if (e.target.tagName === 'A' && e.target.getAttribute('href').startsWith('#')) {
        e.preventDefault();
        
        const targetId = e.target.getAttribute('href');
        const targetElement = document.querySelector(targetId);
        
        if (targetElement) {
            // Quickly scroll to the target element
            window.scrollTo({
                top: targetElement.offsetTop - 100, // Adjust for fixed header
                behavior: 'auto' // No smooth scrolling, immediate jump
            });

            // Update active link immediately
            document.querySelectorAll('.sidebar a').forEach(link => link.classList.remove('active'));
            e.target.classList.add('active');
        }
    }
});
});


window.onload = function() {
document.getElementById("Visualization").scrollIntoView();
};

</script>
<script src="js/A.js"></script>
 <!-- Bootstrap JS and dependencies -->
 <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
 <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
 <script src="js/index2.js"></script>
 <script>
    function handleStepActivation(selector, stepClass) {
        document.querySelectorAll(selector + ' .step a').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault(); // Prevent default anchor behavior
                
                // Find the index of the clicked step
                const clickedStepIndex = Array.from(this.closest('.step').parentNode.children).indexOf(this.closest('.step'));
                // Reset all steps to default state
                document.querySelectorAll(selector + ' .step').forEach((step, index) => {
                    if (index < clickedStepIndex) {
                        step.classList.add('active');
                        step.querySelector('.line').style.backgroundColor = '#007bff';
                    } else if (index === clickedStepIndex) {
                        step.classList.add('active');
                        step.querySelector('.line').style.backgroundColor = '#d3d3d3'; // Keep the line color of the clicked step default
                    } else {
                        step.classList.remove('active');
                        step.querySelector('.line').style.backgroundColor = '#d3d3d3';
                    }
                });
            });
        });
    }

    // Handle steps for Description submenu
    handleStepActivation('.has-submenu .step-indicator', 'step');

    // Handle steps for Algorithm submenu
    handleStepActivation('.has-submenu .step-indicator2', 'step');
 </script>
</body>
</html>
